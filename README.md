# Opinionate

An automated front-end (or full stack) application code generator/scaffolder, that converts a simple (codeless and declarative) definition into a fully functional application.

*Create a working application in minutes: just bring your own PostgreSQL database!*

Or rather, [PostGraphile](https://github.com/graphile/postgraphile) is used to automatically generate a GraphQL API/back-end (derived from your existing database, using introspection). Then the front-end components are generated similarly from the GraphQL using ES6 template files, and any additional metadata you can provide (see below).

This version of Opinionate includes built-in templates that generate functional front-ends using the latest frameworks and technologies. The generated code is [TypeScript](https://www.typescriptlang.org) (and HTML templates) and is fully human-readable, enabling ongoing development and hand crafting. Alternatively, you can refine or customize the templates to better suit your needs, or you can create your own (which could target other technologies, such as React, see below).

Of course Opinionate can be used with other GraphQL server-side technologies, to automatically generate just the front-end/client.

## Prerequisites

- install [Node.js](https://nodejs.org/en)
- install [PostgreSQL](https://www.postgresql.org)
- install your favoured package manager, e.g. [pnpm](https://pnpm.io/) (alternatively use npm, yarn, etc)
- install [TypeScript](https://www.typescriptlang.org/) globally (you may need elevated privileges, e.g. prefix with sudo) `pnpm -g add typescript`
- install PostGraphile globally `pnpm -g add postgraphile`
- optionally install a good IDE with TypeScript support, e.g. [VS Code](https://code.visualstudio.com)

## Example database installation

- create/configure the PostgreSQL database, e.g. "pagila", as follows:
- Download the sample database, then run psql to import and configure.
```bash
wget https://raw.githubusercontent.com/neondatabase/postgres-sample-dbs/main/pagila.sql
sudo -u postgres psql -d template1
```
- Enter the following SQL commands:
```sql
CREATE USER test WITH PASSWORD 'testpass';
CREATE DATABASE pagila;
\c pagila
\i pagila.sql
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO test;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO test;
\q
```
- Run PostGraphile (in the background) with: `postgraphile -c postgres://test:testpass@/pagila --cors --enhance-graphiql -n localhost -p 5000 -q /graphql &` (or later, with "backend")
- Optionally you can click on the link to GraphiQL generated by the above, and explore the server by entering queries such as: `{allFilms {edges {node {description releaseYear originalLanguageId length rating nodeId}}}}`

## Example [Vue](https://vuejs.org)/[PrimeVue](https://github.com/primefaces/primevue) front-end, using [Vite](https://github.com/vitejs/vite) and [Villus](https://github.com/logaretm/villus)

- install Vite: `pnpm -g add vite`
- make/change to your project directory: `mkdir primevue-pagila && cd primevue-pagila`
- you are advised to initialize version control to help track source code changes (e.g. `git init`)
- copy the template's [package~.json](https://github.com/tjme/opinionate/blob/master/templates/primevue/package~.json) as your new package.json (making adjustments, e.g. occurencies of the database name 'pagila' in the script, as appropriate)
- run the GraphQL server if not done earlier, with `pnpm backend &`
- generate everything: `pnpm gen`, OR do it stage by stage with:
  - create a data sources directory: `mkdir models`
  - install dependencies: `pnpm install`
  - generate JSON schema file: `pnpm gen-json` (alternatively, if not using PostGraphile, use apollo `pnpm gen-json-a` or get-graphql-schema `pnpm gen-json-g`)
  - optionally generate GraphQL schema file: `pnpm gen-gql` (alternatively, ditto the above)
  - create the TypeScript type definitions for the schema: `pnpm gen-ts`
  - create a configuration/overlay (for later enhancement and customization): `pnpm gen-overlay` (WARNING: this will overwrite any previous version/amendments)
  - to automatically (re)generate fully functional components/pages for each GraphQL node/entity, as well as common items: `pnpm gen-code` (WARNING: this will overwrite any previous versions/amendments)
- it would be wise at this stage to use `git add -A && git commit -m "opinionate gen"`
- run the development server, to deliver your new website: `pnpm dev`
- or build: `pnpm build` then run a production version: `pnpm preview`
- See [README~.md](templates/primevue/README~.md) for further details
- Go directly to the Actors page at [Actors](http://localhost:5173/#/Actor), and you should see: ![screenshot](doc/Actors_screenshot.png)
- Go directly to the Actors page at [Films](http://localhost:5173/#/Film), and you should see: ![screenshot](doc/Films_screenshot.png)

- For further examples, see [PrimeVue](doc/primevue-toh.md) [Vue & Vuetify](doc/vue-vuetify-toh.md) and [Angular](doc/angular-toh.md).

## Writing metadata

You can guide and improve the code generation performed by the template, by adding metadata. For example (when using the built-in template), you can specify more user-friendly labels for individual tables and fields, and whether they should appear on List or CRUD pages.

The `opinionate meta` sub-command can be used in a number of ways to help manage the metadata. You can provide the metadata as a (JSON) overlay file, or in the PostgreSQL schema, as table and field comments. It can create starter (SQL and/or JSON) files, where you need only fill in the gaps (which is especially useful if you have a large schema).

### Example usage of the opinionate meta command

You can generate an overlay file with default metadata using `opinionate meta --overlay-out models/overlayOut.json`, similarly you can generate a SQL script to create table and field comments containing metadata using `opinionate meta --comments-out models/comments.pgsql`. These assume there is a `models/schema.json` file describing the GraphQL schema (as produced by PostGraphile), otherwise you should use the `--schema` option to specify an alternative location.

You can define your own metadata structure (e.g. to extend the metadata available to the code generating templates), and this can include code to specify default values. This can simplify the templates, and has the added benefit of allowing some of those settings to be further customized (e.g. in the overlay file) before the final code is generated. Remember though, if you want to read the default metadata from an alternate location (rather than as config in your package.json file), add the metadata file parameter to both commands, e.g. `opinionate meta --default-meta models/customMeta` and `opinionate gen --default-meta models/customMeta`.

Note that you can use `opinionate meta -h` for more help.

## Writing your own Opinionate (ES6) template(s)

You can create your own Opinionate template folder tree, and pass it as a parameter, to generate exactly the code you want. Use the existing [templates](templates) as guides, along with the following tips.

The quoting around all existing ES6 template strings (and any substitutions within them) in your code files must be escaped, ie. backticks: `` ` `` must become ``\` ``, and the beginnings of substituions, i.e. `${` must become `$\{`. Also any backslashes (e.g. for escaping) must be doubled-up.

Then add the substitutions required for the code generation.

For example, use `${entities}` for the array of entities/tables.

Similarly, in templates with filenames containing "\_ENTITIES\_", use `${entity.name}` for the entity/table name.
To generate a list of fields, use: ``// The fields of entity ${entity.name} are: ${entity.fields.filter(f => isField(f)).map(field => `${field.name}`).join("\n")}``.
You can place a guard function at the beginning of such a template, when metadata should determine existence, e.g: ``${!entity.meta.templates.includes("list") ? "" : ` `` (and add `` `} `` at the end).
Escape all embedded backquotes (especially the gql tagged strings) with backslash, e.g:

```js
const Fields = gql\`fragment theFields on ${entity.name} { nodeId,${entity.fields.map(field => `${field.name}`)} }\`;
```

## Motivation

Writing code can be difficult and time consuming, and is often highly repetitive. Code is regularly needed simply to translate from one data representation to another (e.g. SQL to JSON). It would be much easier to produce an application if it could simply be defined (declaratively) in one place, using a single language or notation (some refer to this as DRY: Don't Repeat Yourself).

Though modern frameworks such as Vue and Angular, and technologies such as GraphQL offer a lot of power and flexibility (and their CLIs provides some shortcuts) a lot of boilerplate code is still required to build a full stack application (so it's not very DRY). By making some assumptions (which are arguably opinionated), a lot of boilerplate code can be generated automatically. Even if some of the code is not quite appropriate or requires further development or hand-crafting, it might still save a lot of time. Hopefully also, it might be more efficient to refine the code generation/tool, rather than hand working the code afterwards.

## Structure

![Opinionate UML component diagram](src/Opinionate.png)

Any feedback would be gratefully received!

Thanks,
tim@merrison.co.uk
